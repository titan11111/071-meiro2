<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÆåÂÖ®Áâà„Ç≤„Éº„É†„Éú„Éº„Ç§È¢®Ëø∑Ë∑Ø„Ç≤„Éº„É†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #45a049;
            font-family: 'Courier New', monospace;
        }

        .game-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #45a049;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .gameboy-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 400px;
            width: 100%;
            padding: 20px;
        }

        .gameboy {
            background: #8b956d;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 0 3px #6b7753,
                0 8px 16px rgba(0,0,0,0.3);
            width: 100%;
        }

        .screen {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.8);
        }

        .game-area {
            position: relative;
        }

        .game-info {
            color: #9bbc0f;
            font-size: 10px;
            margin-bottom: 5px;
            text-align: center;
            font-weight: bold;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 3px;
        }

        .life-display {
            color: #ff4444;
        }

        .bomb-display {
            color: #8b008b;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            background: #9bbc0f;
            border: 2px solid #8bac0f;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #9bbc0f;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #9bbc0f;
            z-index: 10;
        }

        .game-over h2 {
            font-size: 16px;
            margin-bottom: 10px;
        }

        .game-over p {
            font-size: 12px;
            margin-bottom: 15px;
        }

        .game-btn {
            background: #9bbc0f;
            color: #1e1e1e;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            margin: 0 5px;
            font-size: 12px;
            transition: all 0.1s;
        }

        .game-btn:hover {
            background: #8bac0f;
            transform: scale(1.05);
        }

        .game-btn:active {
            transform: scale(0.95);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }

        .dpad {
            position: relative;
            width: 90px;
            height: 90px;
        }

        .dpad-btn {
            position: absolute;
            background: linear-gradient(145deg, #5a6149, #3a3f2f);
            border: 2px solid #2a2f1f;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.1s;
            user-select: none;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .dpad-btn:active {
            background: linear-gradient(145deg, #3a3f2f, #2a2f1f);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .dpad-btn:hover {
            background: linear-gradient(145deg, #6a7159, #4a5139);
        }

        .up {
            width: 28px;
            height: 35px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .down {
            width: 28px;
            height: 35px;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .left {
            width: 35px;
            height: 28px;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .right {
            width: 35px;
            height: 28px;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .action-buttons {
            display: flex;
            gap: 18px;
        }

        .action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(145deg, #5a6149, #3a3f2f);
            border: 3px solid #2a2f1f;
            color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .action-btn:active {
            background: linear-gradient(145deg, #3a3f2f, #2a2f1f);
            transform: scale(0.9);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .action-btn:hover {
            background: linear-gradient(145deg, #6a7159, #4a5139);
            transform: scale(1.05);
        }

        .instructions {
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            text-align: center;
            border: 2px solid #2d5016;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .instructions h3 {
            color: #2d5016;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .instructions p {
            color: #333;
            font-size: 11px;
            margin: 3px 0;
            line-height: 1.3;
        }

        /* ÊåØÂãïÂäπÊûú */
        .vibrate {
            animation: vibrate 0.1s;
        }

        @keyframes vibrate {
            0% { transform: translate(0); }
            25% { transform: translate(-1px, 1px); }
            50% { transform: translate(1px, -1px); }
            75% { transform: translate(-1px, -1px); }
            100% { transform: translate(0); }
        }

        /* „Çπ„Éû„ÉõÂØæÂøú */
        @media (max-width: 480px) {
            .gameboy-container {
                padding: 10px;
                max-width: 350px;
            }
            
            .gameboy {
                padding: 15px;
            }
            
            .screen {
                padding: 10px;
            }
            
            .game-info {
                font-size: 9px;
            }
            
            .dpad {
                width: 75px;
                height: 75px;
            }
            
            .dpad-btn {
                font-size: 12px;
            }
            
            .up, .down {
                width: 24px;
                height: 30px;
            }
            
            .left, .right {
                width: 30px;
                height: 24px;
            }
            
            .action-btn {
                width: 42px;
                height: 42px;
                font-size: 14px;
            }
            
            .instructions {
                padding: 12px;
            }
            
            .instructions h3 {
                font-size: 14px;
            }
            
            .instructions p {
                font-size: 10px;
            }
        }

        @media (max-width: 320px) {
            .gameboy-container {
                max-width: 300px;
                padding: 5px;
            }
            
            .gameboy {
                padding: 10px;
            }
            
            .dpad {
                width: 65px;
                height: 65px;
            }
            
            .action-btn {
                width: 38px;
                height: 38px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="gameboy-container">
            <div class="gameboy">
                <div class="screen">
                    <div class="game-area">
                        <div class="game-info">
                            <span>LV:<span id="level">1</span></span>
                            <span class="life-display">‚ô•:<span id="lives">3</span></span>
                            <span class="bomb-display">üí£:<span id="bombs">0</span></span>
                            <span>Time:<span id="timer">0</span></span>
                        </div>
                        <canvas id="gameCanvas" width="160" height="144"></canvas>
                        <div class="game-over" id="gameOver" style="display: none;">
                            <h2 id="gameOverTitle">„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ</h2>
                            <p id="gameOverText">ÊôÇÈñì: <span id="finalTime">0</span>Áßí</p>
                            <div>
                                <button class="game-btn" id="nextBtn" style="display: none;">Ê¨°„Å∏</button>
                                <button class="game-btn" id="restartBtn">„É™„Çπ„Çø„Éº„Éà</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="dpad">
                        <button class="dpad-btn up" id="upBtn">‚Üë</button>
                        <button class="dpad-btn left" id="leftBtn">‚Üê</button>
                        <button class="dpad-btn right" id="rightBtn">‚Üí</button>
                        <button class="dpad-btn down" id="downBtn">‚Üì</button>
                    </div>
                    <div class="action-buttons">
                        <button class="action-btn" id="actionBtn">A</button>
                        <button class="action-btn" id="bombBtn">B</button>
                    </div>
                </div>
            </div>
            <div class="instructions">
                <h3>Êã°ÂºµÁâà„ÅÇ„Åù„Å≥„Åã„Åü</h3>
                <p>„ÉªÁ∑ë‚ñ†„Åå„Éó„É¨„Ç§„É§„Éº„ÄÅËµ§‚ñ†„Åå„Ç¥„Éº„É´</p>
                <p>„ÉªÈùí‚óè„ÅØ„Ç≥„Ç§„É≥Ôºà10ÁÇπÔºâ„ÄÅÈªÑ‚óè„ÅØ„Çπ„Éî„Éº„Éâ„Ç¢„ÉÉ„Éó</p>
                <p>„ÉªÁ¥´‚óè„ÅØÁàÜÂºæ„Ç¢„Ç§„ÉÜ„É†ÔºàÊ∫ñÂÇô‰∏≠Ôºâ„ÄÅ„Éî„É≥„ÇØ‚óè„ÅØ„É©„Ç§„ÉïÂõûÂæ©</p>
                <p>„ÉªËµ§‚óè„ÅÆÊïµ„Å´Ëß¶„Çã„Å®1„É©„Ç§„ÉïÊ∏õ„Çã</p>
                <p>„ÉªA„Éú„Çø„É≥Ôºö„ÉÄ„ÉÉ„Ç∑„É•„ÄÅB„Éú„Çø„É≥ÔºöÊ∫ñÂÇô‰∏≠</p>
            </div>
        </div>
    </div>

    <script>
        // „Éî„Ç≥„Éî„Ç≥Èü≥ÁîüÊàêÈñ¢Êï∞
        function playSound(frequency, duration, type = 'square') {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Èü≥Â£∞ÂÜçÁîü„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
            }
        }

        // ÂäπÊûúÈü≥
        const sounds = {
            move: () => playSound(200, 0.1),
            collect: () => playSound(400, 0.2),
            damage: () => playSound(150, 0.3),
            bomb: () => playSound(100, 0.4),
            levelComplete: () => {
                playSound(300, 0.2);
                setTimeout(() => playSound(400, 0.2), 200);
                setTimeout(() => playSound(500, 0.3), 400);
            },
            gameOver: () => {
                playSound(200, 0.3);
                setTimeout(() => playSound(150, 0.3), 300);
                setTimeout(() => playSound(100, 0.5), 600);
            }
        };

        // „Ç≤„Éº„É†Ë®≠ÂÆö
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelElement = document.getElementById('level');
        const livesElement = document.getElementById('lives');
        const bombsElement = document.getElementById('bombs');
        const timerElement = document.getElementById('timer');
        const gameOverElement = document.getElementById('gameOver');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverText = document.getElementById('gameOverText');
        const finalTimeElement = document.getElementById('finalTime');
        const nextBtn = document.getElementById('nextBtn');
        const restartBtn = document.getElementById('restartBtn');

        // „Ç≤„Éº„É†Â§âÊï∞
        let gameRunning = true;
        let currentLevel = 1;
        let startTime = 0;
        let gameTimer = 0;
        let timerInterval;
        let score = 0;
        let lives = 3;
        let playerSpeed = 1;
        let bombs = 0;
        let invulnerable = false;
        const cellSize = 16;
        const mazeWidth = 10;
        const mazeHeight = 9;

        // „Éó„É¨„Ç§„É§„Éº
        let player = {
            x: 1,
            y: 1,
            color: '#0f380f',
            lastMove: 0
        };

        // „Ç¥„Éº„É´
        let goal = {
            x: 8,
            y: 7,
            color: '#8b0000'
        };

        // ÊïµÈÖçÂàó
        let enemies = [];

        // „Ç¢„Ç§„ÉÜ„É†ÈÖçÂàó
        let items = [];

        // „Ç¢„Ç§„ÉÜ„É†„Çø„Ç§„Éó
        const ITEM_TYPES = {
            COIN: { color: '#4169e1', points: 10, symbol: '‚óè' },
            SPEED: { color: '#ffd700', effect: 'speed', symbol: '‚óè' },
            BOMB: { color: '#8b008b', effect: 'bomb', symbol: '‚óè' },
            LIFE: { color: '#ff69b4', effect: 'life', symbol: '‚óè' }
        };

        // Ëø∑Ë∑Ø„Éë„Çø„Éº„É≥
        const mazePatterns = [
            // „É¨„Éô„É´1
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,0,1],
                [1,0,1,0,1,0,1,1,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,1,0,1],
                [1,1,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ],
            // „É¨„Éô„É´2
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,1],
                [1,0,1,1,1,0,1,0,1,1],
                [1,0,0,0,1,0,0,0,0,1],
                [1,1,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,1,0,1],
                [1,0,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ],
            // „É¨„Éô„É´3
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,0,1],
                [1,0,1,0,1,0,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ]
        ];

        let currentMaze = [];

        // „Éú„Çø„É≥ÊåØÂãïÂäπÊûú
        function vibrateButton(element) {
            element.classList.add('vibrate');
            setTimeout(() => element.classList.remove('vibrate'), 100);
        }

        // „Ç≤„Éº„É†ÂàùÊúüÂåñ
        function initGame() {
            gameRunning = true;
            gameOverElement.style.display = 'none';
            
            // „Éó„É¨„Ç§„É§„ÉºÁä∂ÊÖã„É™„Çª„ÉÉ„Éà
            player.x = 1;
            player.y = 1;
            player.lastMove = 0;
            playerSpeed = 1;
            invulnerable = false;
            
            // „É©„Ç§„ÉïÁÆ°ÁêÜ
            if (currentLevel === 1) {
                lives = 3;
                score = 0;
                bombs = 1; // ÂàùÊúüÁàÜÂºæ1ÂÄã
            }
            
            // Ëø∑Ë∑ØË®≠ÂÆö
            currentMaze = mazePatterns[currentLevel - 1] || mazePatterns[mazePatterns.length - 1];
            
            // Êïµ„Å®„Ç¢„Ç§„ÉÜ„É†ÁîüÊàê
            generateEnemies();
            generateItems();
            
            // „Çø„Ç§„Éû„ÉºÈñãÂßã
            startTime = Date.now();
            gameTimer = 0;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 100);
            
            // UIÊõ¥Êñ∞
            updateUI();
            
            // „Ç≤„Éº„É†„É´„Éº„ÉóÈñãÂßã
            gameLoop();
        }

        // ÊïµÁîüÊàê
        function generateEnemies() {
            enemies = [];
            const enemyCount = currentLevel + 1;
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                } while (currentMaze[y][x] !== 0 || (x === player.x && y === player.y) || (x === goal.x && y === goal.y));
                
                enemies.push({
                    x: x,
                    y: y,
                    direction: Math.floor(Math.random() * 4),
                    lastMove: 0,
                    color: '#8b0000'
                });
            }
        }

        // „Ç¢„Ç§„ÉÜ„É†ÁîüÊàê
        function generateItems() {
            items = [];
            const itemCount = 3 + currentLevel;
            
            for (let i = 0; i < itemCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                } while (currentMaze[y][x] !== 0 || (x === player.x && y === player.y) || 
                         (x === goal.x && y === goal.y) || 
                         enemies.some(e => e.x === x && e.y === y));
                
                // „Ç¢„Ç§„ÉÜ„É†„Çø„Ç§„Éó„Çí„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                const typeKeys = Object.keys(ITEM_TYPES);
                const randomType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
                
                items.push({
                    x: x,
                    y: y,
                    type: randomType,
                    collected: false
                });
            }
        }

        // UIÊõ¥Êñ∞
        function updateUI() {
            levelElement.textContent = currentLevel;
            livesElement.textContent = lives;
            bombsElement.textContent = bombs;
            timerElement.textContent = gameTimer;
        }

        // „Çø„Ç§„Éû„ÉºÊõ¥Êñ∞
        function updateTimer() {
            if (gameRunning) {
                gameTimer = Math.floor((Date.now() - startTime) / 1000);
                updateUI();
            }
        }

        // Ëø∑Ë∑ØÊèèÁîª
        function drawMaze() {
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const cell = currentMaze[y][x];
                    const drawX = x * cellSize;
                    const drawY = y * cellSize;
                    
                    if (cell === 1) {
                        ctx.fillStyle = '#0f380f';
                        ctx.fillRect(drawX, drawY, cellSize, cellSize);
                    } else {
                        ctx.fillStyle = '#9bbc0f';
                        ctx.fillRect(drawX, drawY, cellSize, cellSize);
                        
                        if ((x + y) % 3 === 0) {
                            ctx.fillStyle = '#8bac0f';
                            ctx.fillRect(drawX + 7, drawY + 7, 2, 2);
                        }
                    }
                }
            }
        }

        // „Éó„É¨„Ç§„É§„ÉºÊèèÁîª
        function drawPlayer() {
            const drawX = player.x * cellSize + 2;
            const drawY = player.y * cellSize + 2;
            const size = cellSize - 4;
            
            // ÁÑ°ÊïµÊôÇ„ÅÆÁÇπÊªÖ
            if (invulnerable && Math.floor(Date.now() / 100) % 2) {
                ctx.fillStyle = '#ffffff';
            } else {
                ctx.fillStyle = player.color;
            }
            
            ctx.fillRect(drawX, drawY, size, size);
            
            // „Éó„É¨„Ç§„É§„Éº„ÅÆÁõÆ
            ctx.fillStyle = '#9bbc0f';
            ctx.fillRect(drawX + 3, drawY + 3, 2, 2);
            ctx.fillRect(drawX + 7, drawY + 3, 2, 2);
        }

        // ÊïµÊèèÁîª
        function drawEnemies() {
            enemies.forEach(enemy => {
                const drawX = enemy.x * cellSize + 3;
                const drawY = enemy.y * cellSize + 3;
                const size = cellSize - 6;
                
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(drawX + size/2, drawY + size/2, size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Êïµ„ÅÆÁõÆ
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(drawX + 2, drawY + 2, 1, 1);
                ctx.fillRect(drawX + 5, drawY + 2, 1, 1);
            });
        }

        // „Ç¢„Ç§„ÉÜ„É†ÊèèÁîª
        function drawItems() {
            items.forEach(item => {
                if (!item.collected) {
                    const drawX = item.x * cellSize + 4;
                    const drawY = item.y * cellSize + 4;
                    const size = cellSize - 8;
                    
                    const itemType = ITEM_TYPES[item.type];
                    ctx.fillStyle = itemType.color;
                    ctx.beginPath();
                    ctx.arc(drawX + size/2, drawY + size/2, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // „Ç¢„Ç§„ÉÜ„É†„ÅÆËºù„Åç
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(drawX + 2, drawY + 2, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // „Ç¥„Éº„É´ÊèèÁîª
        function drawGoal() {
            const drawX = goal.x * cellSize + 2;
            const drawY = goal.y * cellSize + 2;
            const size = cellSize - 4;
            
            const flash = Math.floor(Date.now() / 300) % 2;
            ctx.fillStyle = flash ? goal.color : '#ff4444';
            ctx.fillRect(drawX, drawY, size, size);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(drawX + 4, drawY + 2, 4, 2);
            ctx.fillRect(drawX + 4, drawY + 6, 4, 2);
            ctx.fillRect(drawX + 4, drawY + 10, 4, 2);
        }

        // ËÉåÊôØÊèèÁîª
        function drawBackground() {
            ctx.fillStyle = '#9bbc0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ÁßªÂãïÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        function canMove(x, y) {
            if (x < 0 || x >= mazeWidth || y < 0 || y >= mazeHeight) {
                return false;
            }
            return currentMaze[y][x] === 0;
        }

        // ÊïµAI
        function updateEnemies() {
            const now = Date.now();
            enemies.forEach(enemy => {
                if (now - enemy.lastMove > 800) {
                    const directions = [
                        { dx: 0, dy: -1 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: -1, dy: 0 }
                    ];
                    
                    let moved = false;
                    let attempts = 0;
                    
                    while (!moved && attempts < 4) {
                        const dir = directions[enemy.direction];
                        const newX = enemy.x + dir.dx;
                        const newY = enemy.y + dir.dy;
                        
                        if (canMove(newX, newY)) {
                            enemy.x = newX;
                            enemy.y = newY;
                            moved = true;
                        } else {
                            enemy.direction = (enemy.direction + 1) % 4;
                        }
                        attempts++;
                    }
                    
                    enemy.lastMove = now;
                }
            });
        }

        // „Ç¢„Ç§„ÉÜ„É†ÂèéÈõÜ„ÉÅ„Çß„ÉÉ„ÇØ
        function checkItemCollection() {
            items.forEach(item => {
                if (!item.collected && item.x === player.x && item.y === player.y) {
                    item.collected = true;
                    const itemType = ITEM_TYPES[item.type];
                    
                    switch(item.type) {
                        case 'COIN':
                            score += itemType.points;
                            sounds.collect();
                            break;
                        case 'SPEED':
                            playerSpeed = 2;
                            setTimeout(() => playerSpeed = 1, 5000);
                            sounds.collect();
                            break;
                        case 'BOMB':
                            bombs++;
                            sounds.collect();
                            break;
                        case 'LIFE':
                            if (lives < 3) lives++;
                            sounds.collect();
                            break;
                    }
                    
                    // ÂäπÊûúÈü≥‰ª£„Çè„Çä„ÅÆÁîªÈù¢„Éï„É©„ÉÉ„Ç∑„É•
                    flashScreen('#ffffff');
                    updateUI();
                }
            });
        }

        // Êïµ„Å®„ÅÆË°ùÁ™Å„ÉÅ„Çß„ÉÉ„ÇØ
        function checkEnemyCollision() {
            if (invulnerable) return;
            
            enemies.forEach(enemy => {
                if (enemy.x === player.x && enemy.y === player.y) {
                    lives--;
                    invulnerable = true;
                    
                    // ÁÑ°ÊïµÊôÇÈñì
                    setTimeout(() => invulnerable = false, 2000);
                    
                    sounds.damage();
                    flashScreen('#ff0000');
                    updateUI();
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // ÁàÜÂºæ‰ΩøÁî®
        function useBomb() {
            if (bombs > 0) {
                bombs--;
                
                console.log(`ÁàÜÂºæ‰ΩøÁî®ÔºÅÊÆã„ÇäÁàÜÂºæ: ${bombs}`);
                console.log(`„Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ: (${player.x}, ${player.y})`);
                
                // Êïµ„ÅÆ‰ΩçÁΩÆ„Çí„É≠„Ç∞Âá∫Âäõ
                enemies.forEach((enemy, index) => {
                    const distance = Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y);
                    console.log(`Êïµ${index}: (${enemy.x}, ${enemy.y}) Ë∑ùÈõ¢: ${distance}`);
                });
                
                // ÁàÜÂºæ„Ç®„Éï„Çß„ÇØ„ÉàÊèèÁîª
                drawBombExplosion();
                
                // „Éó„É¨„Ç§„É§„ÉºÂë®Ëæ∫„ÅÆÊïµ„ÇíÈô§ÂéªÔºàÁØÑÂõ≤„Çí3„Å´Êã°Â§ßÔºâ
                const initialEnemyCount = enemies.length;
                const enemiesInRange = enemies.filter(enemy => {
                    const distance = Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y);
                    return distance <= 3; // ÁØÑÂõ≤„Çí3„Å´Êã°Â§ß
                });
                
                enemies = enemies.filter(enemy => {
                    const distance = Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y);
                    return distance > 3; // ÁØÑÂõ≤„Çí3„Å´Êã°Â§ß
                });
                
                const enemiesDestroyed = initialEnemyCount - enemies.length;
                console.log(`Êïµ„Çí${enemiesDestroyed}‰ΩìÊíÉÁ†¥`);
                
                if (enemiesDestroyed > 0) {
                    sounds.bomb();
                    score += enemiesDestroyed * 25;
                    
                    // ÁîªÈù¢„Éï„É©„ÉÉ„Ç∑„É•„ÇíÁü≠Á∏Æ
                    setTimeout(() => flashScreen('#ffff00'), 100);
                    setTimeout(() => flashScreen('#ffffff'), 200);
                } else {
                    // Êïµ„Åå„ÅÑ„Å™„Åè„Å¶„ÇÇÁàÜÂºæÈü≥„ÅØÈ≥¥„Çã
                    sounds.bomb();
                    setTimeout(() => flashScreen('#ffaa00'), 100);
                }
                
                updateUI();
            } else {
                console.log('ÁàÜÂºæ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                // ÁàÜÂºæ„Åå„Å™„ÅÑÊôÇ„ÅÆÂäπÊûúÈü≥
                playSound(100, 0.2);
                
                // ÁîªÈù¢„ÇíËµ§„ÅèÁÇπÊªÖ„Åï„Åõ„Å¶ÁàÜÂºæ‰∏çË∂≥„ÇíÁü•„Çâ„Åõ„Çã
                flashScreen('#ff0000');
            }
        }

        // ÁàÜÂºæÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà
        function drawBombExplosion() {
            const explosionRange = 3;
            let effectFrame = 0;
            
            // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            function animateExplosion() {
                if (effectFrame < 8) {
                    // ÈÄöÂ∏∏„ÅÆÊèèÁîª„Çí‰∏ÄÊôÇÂÅúÊ≠¢
                    ctx.save();
                    
                    // ËÉåÊôØ„ÇíÂÜçÊèèÁîª
                    drawBackground();
                    drawMaze();
                    drawItems();
                    drawGoal();
                    drawEnemies();
                    
                    // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÊèèÁîª
                    ctx.globalAlpha = 0.8 - (effectFrame * 0.1);
                    
                    for (let dx = -explosionRange; dx <= explosionRange; dx++) {
                        for (let dy = -explosionRange; dy <= explosionRange; dy++) {
                            const distance = Math.abs(dx) + Math.abs(dy);
                            if (distance <= explosionRange) {
                                const x = (player.x + dx) * cellSize;
                                const y = (player.y + dy) * cellSize;
                                
                                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                                    // ÁàÜÁô∫„ÅÆËâ≤„ÇíË∑ùÈõ¢„Å®„Éï„É¨„Éº„É†„ÅßÂ§âÂåñ
                                    if (distance === 0) {
                                        ctx.fillStyle = effectFrame % 2 ? '#ffffff' : '#ffff00';
                                    } else if (distance <= 1) {
                                        ctx.fillStyle = effectFrame % 2 ? '#ffff00' : '#ff8800';
                                    } else if (distance <= 2) {
                                        ctx.fillStyle = effectFrame % 2 ? '#ff8800' : '#ff4400';
                                    } else {
                                        ctx.fillStyle = effectFrame % 2 ? '#ff4400' : '#aa2200';
                                    }
                                    
                                    // ÁàÜÁô∫ÁØÑÂõ≤„ÇíÊèèÁîª
                                    ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                                    
                                    // ÁÅ´Ëä±„Ç®„Éï„Çß„ÇØ„Éà
                                    if (effectFrame < 4 && Math.random() < 0.3) {
                                        ctx.fillStyle = '#ffffff';
                                        ctx.globalAlpha = 1;
                                        const sparkX = x + Math.random() * cellSize;
                                        const sparkY = y + Math.random() * cellSize;
                                        ctx.fillRect(sparkX, sparkY, 2, 2);
                                        ctx.globalAlpha = 0.8 - (effectFrame * 0.1);
                                    }
                                }
                            }
                        }
                    }
                    
                    // „Éó„É¨„Ç§„É§„Éº„ÇíÊúÄÂæå„Å´ÊèèÁîª
                    drawPlayer();
                    
                    ctx.restore();
                    
                    effectFrame++;
                    setTimeout(animateExplosion, 60);
                } else {
                    // „Ç®„Éï„Çß„ÇØ„ÉàÁµÇ‰∫ÜÂæå„ÄÅÈÄöÂ∏∏ÊèèÁîª„Å´Êàª„Çã
                    ctx.globalAlpha = 1;
                    canvas.style.filter = 'none';
                }
            }
            
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
            animateExplosion();
        }

        // ÁîªÈù¢„Éï„É©„ÉÉ„Ç∑„É•ÂäπÊûú
        function flashScreen(color = '#ffffff') {
            canvas.style.filter = `drop-shadow(0 0 10px ${color})`;
            setTimeout(() => {
                canvas.style.filter = 'none';
            }, 150);
        }

        // „Éó„É¨„Ç§„É§„ÉºÁßªÂãï
        function movePlayer(dx, dy, isDash = false) {
            if (!gameRunning) return;
            
            const now = Date.now();
            const moveDelay = isDash ? 50 : (200 / playerSpeed);
            
            if (now - player.lastMove < moveDelay) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (canMove(newX, newY)) {
                player.x = newX;
                player.y = newY;
                player.lastMove = now;
                
                sounds.move();
                
                checkItemCollection();
                checkEnemyCollision();
                
                if (player.x === goal.x && player.y === goal.y) {
                    levelComplete();
                }
            }
        }

        // „É¨„Éô„É´„ÇØ„É™„Ç¢
        function levelComplete() {
            gameRunning = false;
            clearInterval(timerInterval);
            
            const timeBonus = Math.max(0, 60 - gameTimer) * 5;
            score += timeBonus;
            
            sounds.levelComplete();
            
            finalTimeElement.textContent = gameTimer;
            
            if (currentLevel < mazePatterns.length) {
                gameOverTitle.textContent = '„É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ';
                gameOverText.innerHTML = `„Çπ„Ç≥„Ç¢: ${score}<br>ÊôÇÈñì: ${gameTimer}Áßí<br>„Éú„Éº„Éä„Çπ: +${timeBonus}`;
                nextBtn.style.display = 'inline-block';
            } else {
                gameOverTitle.textContent = 'ÂÖ®„É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ';
                gameOverText.innerHTML = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}<br>„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ`;
                nextBtn.style.display = 'none';
            }
            
            gameOverElement.style.display = 'block';
        }

        // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
        function gameOver() {
            gameRunning = false;
            clearInterval(timerInterval);
            
            sounds.gameOver();
            
            gameOverTitle.textContent = '„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº';
            gameOverText.innerHTML = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}<br>„É¨„Éô„É´${currentLevel}„ÅßÁµÇ‰∫Ü`;
            nextBtn.style.display = 'none';
            gameOverElement.style.display = 'block';
        }

        // Ê¨°„ÅÆ„É¨„Éô„É´
        function nextLevel() {
            if (currentLevel < mazePatterns.length) {
                currentLevel++;
                initGame();
            }
        }

        // „Ç≤„Éº„É†„É™„Çª„ÉÉ„Éà
        function resetGame() {
            currentLevel = 1;
            score = 0;
            lives = 3;
            initGame();
        }

        // „Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            if (!gameRunning) return;
            
            drawBackground();
            drawMaze();
            drawItems();
            drawGoal();
            drawEnemies();
            drawPlayer();
            
            updateEnemies();
            
            requestAnimationFrame(gameLoop);
        }

        // „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú
        let keysPressed = {};
        
        document.addEventListener('keydown', (e) => {
            if (keysPressed[e.key]) return;
            keysPressed[e.key] = true;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    movePlayer(0, -1);
                    vibrateButton(document.getElementById('upBtn'));
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    movePlayer(0, 1);
                    vibrateButton(document.getElementById('downBtn'));
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    vibrateButton(document.getElementById('leftBtn'));
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePlayer(1, 0);
                    vibrateButton(document.getElementById('rightBtn'));
                    break;
                case ' ':
                case 'b':
                case 'B':
                    e.preventDefault();
                    useBomb();
                    vibrateButton(document.getElementById('bombBtn'));
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // „Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅÆÊîπÂñÑ
        let touchInterval;
        let isDashing = false;
        let repeatDelay = 150;

        function startMove(direction, button) {
            vibrateButton(button);
            movePlayer(...direction, isDashing);
            
            clearInterval(touchInterval);
            touchInterval = setInterval(() => {
                if (button.matches(':active')) {
                    movePlayer(...direction, isDashing);
                }
            }, repeatDelay);
        }

        function stopMove() {
            clearInterval(touchInterval);
            isDashing = false;
        }

        // ÊñπÂêë„Éú„Çø„É≥„ÅÆÊîπÂñÑ„Åï„Çå„Åü„Ç§„Éô„É≥„Éà
        const directions = [
            { btn: 'upBtn', dir: [0, -1] },
            { btn: 'downBtn', dir: [0, 1] },
            { btn: 'leftBtn', dir: [-1, 0] },
            { btn: 'rightBtn', dir: [1, 0] }
        ];

        directions.forEach(({ btn, dir }) => {
            const button = document.getElementById(btn);
            
            // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà
            button.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startMove(dir, button);
            });
            
            button.addEventListener('mouseup', stopMove);
            button.addEventListener('mouseleave', stopMove);
            
            // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startMove(dir, button);
            });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopMove();
            });
            
            button.addEventListener('touchcancel', stopMove);
        });

        // „Ç¢„ÇØ„Ç∑„Éß„É≥„Éú„Çø„É≥„ÅÆÊîπÂñÑ
        const actionBtn = document.getElementById('actionBtn');
        const bombBtn = document.getElementById('bombBtn');

        // A„Éú„Çø„É≥Ôºà„ÉÄ„ÉÉ„Ç∑„É•Ôºâ
        actionBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDashing = true;
            vibrateButton(actionBtn);
            repeatDelay = 80;
        });

        actionBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            isDashing = false;
            repeatDelay = 150;
        });

        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDashing = true;
            vibrateButton(actionBtn);
            repeatDelay = 80;
        });

        actionBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDashing = false;
            repeatDelay = 150;
        });

        // B„Éú„Çø„É≥ÔºàÁàÜÂºæÔºâ
        bombBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            useBomb();
            vibrateButton(bombBtn);
        });

        bombBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            useBomb();
            vibrateButton(bombBtn);
        });

        // „Ç≤„Éº„É†Âà∂Âæ°„Éú„Çø„É≥
        nextBtn.addEventListener('click', (e) => {
            e.preventDefault();
            vibrateButton(nextBtn);
            nextLevel();
        });

        restartBtn.addEventListener('click', (e) => {
            e.preventDefault();
            vibrateButton(restartBtn);
            resetGame();
        });

        // ÁîªÈù¢„Çø„ÉÉ„ÉÅ„ÅßÈü≥Â£∞„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊúâÂäπÂåñ
        document.addEventListener('touchstart', function enableAudio() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.resume();
            } catch (error) {
                console.log('Èü≥Â£∞ÂàùÊúüÂåñ„Ç®„É©„Éº');
            }
            document.removeEventListener('touchstart', enableAudio);
        }, { once: true });

        // „Ç≤„Éº„É†ÈñãÂßã
        initGame();
    </script>
</body>
</html>